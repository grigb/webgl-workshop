<!DOCTYPE html>
<html>
<head>
	<title>Shader Workshop</title>
	<meta charset="utf-8">
	<link rel="stylesheet" type="text/css" href="fonts/icons/style.css">
	<link rel="stylesheet" type="text/css" href="css/app.css">

	<style id="ace-tm">.ace-tm .ace_gutter {background: #f0f0f0;color: #333;}.ace-tm .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-tm .ace_fold {background-color: #6B72E6;}.ace-tm {background-color: #FFFFFF;color: black;}.ace-tm .ace_cursor {color: black;}.ace-tm .ace_invisible {color: rgb(191, 191, 191);}.ace-tm .ace_storage,.ace-tm .ace_keyword {color: blue;}.ace-tm .ace_constant {color: rgb(197, 6, 11);}.ace-tm .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-tm .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-tm .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-tm .ace_invalid {background-color: rgba(255, 0, 0, 0.1);color: red;}.ace-tm .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-tm .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-tm .ace_support.ace_type,.ace-tm .ace_support.ace_class {color: rgb(109, 121, 222);}.ace-tm .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-tm .ace_string {color: rgb(3, 106, 7);}.ace-tm .ace_comment {color: rgb(76, 136, 107);}.ace-tm .ace_comment.ace_doc {color: rgb(0, 102, 255);}.ace-tm .ace_comment.ace_doc.ace_tag {color: rgb(128, 159, 191);}.ace-tm .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-tm .ace_variable {color: rgb(49, 132, 149);}.ace-tm .ace_xml-pe {color: rgb(104, 104, 91);}.ace-tm .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-tm .ace_heading {color: rgb(12, 7, 255);}.ace-tm .ace_list {color:rgb(185, 6, 144);}.ace-tm .ace_meta.ace_tag {color:rgb(0, 22, 142);}.ace-tm .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-tm .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-tm.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px white;border-radius: 2px;}.ace-tm .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-tm .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-tm .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-tm .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-tm .ace_gutter-active-line {background-color : #dcdcdc;}.ace-tm .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-tm .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}</style>

	<style id="ace-tomorrow-night">.ace-tomorrow-night .ace_gutter {background: #25282c;color: #C5C8C6}.ace-tomorrow-night .ace_print-margin {width: 1px;background: #25282c}.ace-tomorrow-night {background-color: #1D1F21;color: #C5C8C6}.ace-tomorrow-night .ace_cursor {color: #AEAFAD}.ace-tomorrow-night .ace_marker-layer .ace_selection {background: #373B41}.ace-tomorrow-night.ace_multiselect .ace_selection.ace_start {box-shadow: 0 0 3px 0px #1D1F21;border-radius: 2px}.ace-tomorrow-night .ace_marker-layer .ace_step {background: rgb(102, 82, 0)}.ace-tomorrow-night .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid #4B4E55}.ace-tomorrow-night .ace_marker-layer .ace_active-line {background: #282A2E}.ace-tomorrow-night .ace_gutter-active-line {background-color: #282A2E}.ace-tomorrow-night .ace_marker-layer .ace_selected-word {border: 1px solid #373B41}.ace-tomorrow-night .ace_invisible {color: #4B4E55}.ace-tomorrow-night .ace_keyword,.ace-tomorrow-night .ace_meta,.ace-tomorrow-night .ace_storage,.ace-tomorrow-night .ace_storage.ace_type,.ace-tomorrow-night .ace_support.ace_type {color: #B294BB}.ace-tomorrow-night .ace_keyword.ace_operator {color: #8ABEB7}.ace-tomorrow-night .ace_constant.ace_character,.ace-tomorrow-night .ace_constant.ace_language,.ace-tomorrow-night .ace_constant.ace_numeric,.ace-tomorrow-night .ace_keyword.ace_other.ace_unit,.ace-tomorrow-night .ace_support.ace_constant,.ace-tomorrow-night .ace_variable.ace_parameter {color: #DE935F}.ace-tomorrow-night .ace_constant.ace_other {color: #CED1CF}.ace-tomorrow-night .ace_invalid {color: #CED2CF;background-color: #DF5F5F}.ace-tomorrow-night .ace_invalid.ace_deprecated {color: #CED2CF;background-color: #B798BF}.ace-tomorrow-night .ace_fold {background-color: #81A2BE;border-color: #C5C8C6}.ace-tomorrow-night .ace_entity.ace_name.ace_function,.ace-tomorrow-night .ace_support.ace_function,.ace-tomorrow-night .ace_variable {color: #81A2BE}.ace-tomorrow-night .ace_support.ace_class,.ace-tomorrow-night .ace_support.ace_type {color: #F0C674}.ace-tomorrow-night .ace_heading,.ace-tomorrow-night .ace_markup.ace_heading,.ace-tomorrow-night .ace_string {color: #B5BD68}.ace-tomorrow-night .ace_entity.ace_name.ace_tag,.ace-tomorrow-night .ace_entity.ace_other.ace_attribute-name,.ace-tomorrow-night .ace_meta.ace_tag,.ace-tomorrow-night .ace_string.ace_regexp,.ace-tomorrow-night .ace_variable {color: #CC6666}.ace-tomorrow-night .ace_comment {color: #969896}.ace-tomorrow-night .ace_indent-guide {background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAEklEQVQImWNgYGBgYHB3d/8PAAOIAdULw8qMAAAAAElFTkSuQmCC) right repeat-y}</style>
</head>
<body>

	<div id="top-bar">
		<div class="left-menu">
			<header>Shader Workshop</header>
		</div>
		<div class="right-menu">
			<button class="cheat-sheet"><span class="icon-edu"></span> <span>Cheat Sheet</span></button>
			<button class="restart"><span class="icon-previous"></span></button>
			<button class="fullscreen"><span class="icon-screen-full"></span></button>
		</div>
	</div>

	<pre id="editor" class="ace-tomorrow-night ace_dark">void main(){
    vec3 col = vec3(0);
    vec2 r = r;

    float a = angle(r);
    r += normalize(r) * a * 0.4;
    
    float len = length(r);
    
    if(length(r) < .5){
        col = vec3(uv + vec2(sin(time), cos(time))*.25, sin(time + a)*.5 + .5) * pow((.5 - length(r))*2., 1./7.);
    }
    
	gl_FragColor = vec4(col, 1.0);
}</pre>

	<div id="messages">
		<div class="content"></div>
	</div>

	<canvas id="preview"></canvas>

	<!-- cheat sheet -->
	<div id="overlay">
		<div class="close"><span class="icon-cross"></span></div>
		<div class="scroller">
			<div class="content">
				<div class="page">
					<header>
						<h1>Shader Cheatsheet</h1>
						<h6>(just the important bits)</h6>
						<hr>
					</header>

					<p>This is a quick reference for the most used bits of GLSL. Not everything is here so to learn more I recommend these links:</p>
					<ul>
						<li><a href="http://patriciogonzalezvivo.com/2015/thebookofshaders/">The Book Of Shaders</a></li>
						<li><a href="https://www.khronos.org/files/webgl/webgl-reference-card-1_0.pdf" target="_blank">Complete WebGL reference</a></li>
						<li><a href="http://www.shaderific.com/glsl-functions/" target="_blank">List of built-in functions in GLSL</a></li>
						<li><a href="https://en.wikibooks.org/wiki/GLSL_Programming/Vector_and_Matrix_Operations" target="_blank">GLSL language guide</a></li>
					</ul>

					<h3>Contents</h3>
					<ul>
						<li><a href="#glsl-tldr">TL;DR</a></li>
						<li><a href="#glsl-language-guide">Language Guide</a></li>
						<li><a href="#glsl-extras">Extra Variables and Functions</a></li>
						<li><a href="#glsl-built-in-types">Built-in Types</a></li>
						<li><a href="#glsl-built-in-functions">Built-in Functions</a></li>
					</ul>

					<hr>

					<h2 id="glsl-tldr">TL;DR</h2>
					<ul>
						<li>Shader code is run on each pixel separately</li>
						<li>The entry point is the functioned named main
							<pre>
void main(){
	//code starts here
}
							</pre>
						</li>

						<li>Pixels are colored by setting the value of the vector <code>gl_FragColor</code></li>
						<li>You can set vector properties with dot syntax: <code>col.r = 4.2;</code></li>
						<li>Colors values range from 0 to 1; <code>gl_FragColor.r = 1.0;</code> sets the red element to full</li>
						<li>Vectors have properties <code>.x, .y, .z, .w</code> but you can also use <code>.r, .g, .b, .a</code></li>
						<li>Vectors are constructed with the following syntax <pre>vec2 point = vec2(1.3, 4.2); //vec2(x, y)</pre> where the number after 'vec' sets the number of properties</li>
						<li>Most math functions are available (sin, cos, floor etc)</li>
						<li>GLSL is very dumb with data-types:
						<pre>
1.0 + 2;   // Error: wrong operand types
1.0 + 2.0; // 3.0
						</pre>
						The error is because <code>1.0</code> is a <code>float</code> and <code>2</code> is an <code>int</code></li>
					</ul>

					<hr>

					<h2 id="glsl-language-guide">Language Guide</h2>

					<p>GLSL is a very simple language, it supports only a subset of the features normally available in a programming language - most notably, in this version of GLSL there are no arrays, strings, switch statements, classes, console logging or while loops. However, GLSL does have powerful vector and matrix types. Below is an overview of the most commonly used features (but there are others not touched upon).</p>

					<h3>Variables</h3>
					<p>Variables must be defined with a type. The type comes before the variable name</p>
					<pre>
float someVar = 42.0;
int anotherVar = 18;
					</pre>
					<p>Types with properties (like vectors and matricies) require constructing. This is done by calling the type's name as a function and passing the properties as arguments</p>
					<pre>
vec3 color = vec3(0.1, 0.2, 0.3); //vec3(x, y, z)
					</pre>
					<p>The individual properties of the object can then be accessed</p>
					<pre>
color.x = 1.0
color.y = 0.5
color.z = 0.0
					</pre>
					<p>Instead of using x, y, z, w, you can access the same properties with r, g, b, a.</p>
					<p>You can access sub-vectors by using a string of properties (in any order)</p>
					<pre>
vec4 fourVector = vec4(1.0, 2.0, 3.0, 4.0);
vec2 twoVector = fourVector.xy;    //vec2(1.0, 2.0)
vec3 threeVector = fourVector.zzw; //vec3(3.0, 3.0, 4.0)
					</pre>
					<p>This also works for assignment</p>
					<pre>
fourVector.xy = vec2(11.0, 12.0);
//fourVector is now vec4(11.0, 12.0, 3.0, 4.0)
					</pre>

					<h3>Basic Operations</h3>
					<p>
						GLSL supports the standard binary operators <code>*, /, +, -</code>. When performing binary operations, the types must be compatible - GLSL cannot add an <code>int</code> to a <code>float</code>, nor can it automatically convert between them
					</p>
					<pre>
1.0 + 2;   // Error: wrong operand types
1.0 + 2.0; // 3.0
					</pre>
					<p>However, a vector can be multiplied by a <code>float</code> - each element of the vector is multiplied independently</p>
					<pre>vec2(3.0, 4.0) * 4.0; //vec2(12.0, 16.0);</pre>
					<p>This works similarly for matricies</p>
					<p>Other operators include comparisons <code>==, !=, <=, >=, >, <</code> and assignment operators <code>*=, /=, +=, -=</code>, used like so</p>
					<pre>
someVar += 10.0;
					</pre>

					<h3>Functions</h3>
					<p>Function definitions require a return type and a type for each argument</p>
					<pre>
float lengthSquared(vec2 v){
	return pow(length(v), 2.0);
}
					</pre>
					<p>or</p>
					<pre>
void doThing(float value1, vec4 value2){
	//does the thing
}
					</pre>
					<p>Multiple function definitions can have the same name but different parameters (function overloading)</p>
					<pre>
float angle();
float angle(vec2 r);
float angle(vec2 r, vec2 o);
					</pre>
					<p>Functions can only be called after they've been defined. Unless function prototypes are used, <b>only functions defined above the point of execution can be called.</b> A function prototype is just the function header without the code</p>
					<pre>
float lengthSquared(vec2 v);
					</pre>

					<h3>Flow Control Statements</h3>
					<p>GLSL supports basic control statements <code>if</code> and <code>for</code> loops - in WebGL <code>while</code> and <code>do while</code> are forbidden. Additionally, the for loop can only contain constants in the condition.</p>
					<p>The syntax of a <code>if</code> statement is</p>
					<pre>
if(a < b){
	//a is less than b
}else if(a == b){
	//a is the same as b
}else{
	//a is greater than b
}
					</pre>
					<p>A <code>for</code> loop is</p>
					<pre>
for(int i = 0; i < 10; i++){
	//this run 10 times
}
					</pre>

					<h3>Custom Types</h3>
					<p>You can define custom data types with <code>struct</code></p>
					<pre>
struct NewType{
	float someProp;
	vec2 otherProp;
};
					</pre>
					<p>Your custom type is constructed in the same way as other types</p>
					<pre>
NewType instance = NewType(3.1, vec2(10.0, 0.0));
instance.someProp; //3.1
instance.otherProp;	//vec2(10.0, 0.0)
					</pre>

					<hr>

					<h2 id="glsl-extras">Extra Variables and Functions</h2>
					<p><i>These are variables and functions I've setup for this editor, they are not available by default in GLSL</i></p>
					<h3>Variables</h3>
					<table class="mono-title">
						<tr>
							<th>r <span class="info">vec2</span></th><td>Distance from center. Ranges from -0.5 to 0.5 along the shortest axis of the viewport. The other axis is scaled to account for aspect ratio.</td>
						</tr>
						<tr>
							<th>uv <span class="info">vec2</span></th><td>Pixel position where (0, 0) is bottom left and (1, 1) is top right</td>
						</tr>
						<tr>
							<th>time <span class="info">float</span></th><td>Time in seconds since the demo started</td>
						</tr>
						<tr>
							<th>mouse <span class="info">vec3</span></th><td>Coordinate of mouse where (0, 0) is bottom left and (1, 1) is top right. <code>mouse.z</code> is 1.0 when mouse is down and 0.0 otherwise</td>
						</tr>
						<tr>
							<th>resolution <span class="info">vec2</span></th><td>Width and height of canvas in pixels</td>
						</tr>
					</table>
					<h3>Constants</h3>
					<table class="mono-title">
						<tr>
							<th>PI <span class="info">float</span></th><td><code>3.14159265359</code></td>
						</tr>
					</table>
					<h3>Functions</h3>
					<table class="mono-title">
						<tr>
							<th>angle() <span class="info">float</span></th><td>Angle of pixel about center from 0 to 2π</td>
						</tr>
						<!--<tr>
							<th>angle(vec2 p) <span class="info">float</span></th><td>Angle of p about center from 0 to 2π</td>
						</tr>
						<tr>
							<th>angle(vec2 p, vec2 o) <span class="info">float</span></th><td>Angle of p about o from 0 to 2π</td>
						</tr>-->
						<tr>
							<th>rand() <span class="info">float</span></th><td>Random number from 0 to 1</td>
						</tr>
					</table>

					<hr>

					<h2 id="glsl-built-in-types">Built-in Types</h2>

					<table class="mono-title">
						<tr>
							<th>bool</th><td>Either <code>true</code> or <code>false</code></td>
						</tr>
						<tr>
							<th>int</th><td>Whole number (eg: <code>42</code>)</td>
						</tr>
						<tr>
							<th>float</th><td>Number with decimal point (eg: <code>6.283</code>)</td>
						</tr>
						<tr>
							<th>vec2</th><td>Vector with 2 elements (x, y)</td>
						</tr>
						<tr>
							<th>vec3</th><td>Vector with 3 elements (x, y, z)</td>
						</tr>
						<tr>
							<th>vec4</th><td>Vector with 4 elements (x, y, z, w)</td>
						</tr>

						<tr>
							<th>mat2</th><td>2x2 Matrix</td>
						</tr>
						<tr>
							<th>mat3</th><td>3x3 Matrix</td>
						</tr>
						<tr>
							<th>mat4</th><td>4x4 Matrix</td>
						</tr>
						<tr>
							<th>void</th><td>Used when there's no return type or to explicitly define empty parameters</td>
						</tr>
					</table>
					<p>The <span class="mono">vec<i>n</i></span> and <span class="mono">mat<i>n</i></span> types have <code>float</code> elements, for <code>int</code> elements, prefix i and for boolean, prefix b:
					<pre>bvec2 switches = bvec2(true, false);</pre>
					</p>

					<hr>

					<h2 id="glsl-built-in-functions">Built-in Functions</h2>

					<table class="mono-title"><tbody><tr onclick="javascript:"><th>radians(degrees)</th><td title="The radians function converts degrees to radians. The input parameter can be a floating scalar or a float vector. In case of a float vector all components are converted from degrees to radians separately.">Converts degrees to radians. The input parameter can ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#radians">more</a></td></tr><tr onclick="javascript:"><th>degrees(radians)</th><td title="The degrees function converts radians to degrees. The input parameter can be a floating scalar or a float vector. In case of a float vector every component is converted from radians to degrees separately.">Converts radians to degrees. The input parameter can ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#degrees">more</a></td></tr><tr onclick="javascript:"><th>sin(angle)</th><td title="The sin function returns the sine of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the sine is calculated separately for every component.">Returns the sine of an angle in radians. The input ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#sine">more</a></td></tr><tr onclick="javascript:"><th>cos(angle)</th><td title="The cos function returns the cosine of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the cosine is calculated separately for every component.">Returns the cosine of an angle in radians. The input ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#cosine">more</a></td></tr><tr onclick="javascript:"><th>tan(angle)</th><td title="The tan function returns the tangent of an angle in radians. The input parameter can be a floating scalar or a float vector. In case of a float vector the tangent is calculated separately for every component.">Returns the tangent of an angle in radians. The input ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#tangent">more</a></td></tr><tr onclick="javascript:"><th>asin(x)</th><td title="The asin function returns the arcsine of an angle in radians. It is the inverse function of sine. The input parameter can be a floating scalar or a float vector. In case of a float vector the arcsine is calculated separately for every component.">Returns the arcsine of an angle in radians. It is the ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#arcsine">more</a></td></tr><tr onclick="javascript:"><th>acos(x)</th><td title="The acos function returns the arccosine of an angle in radians. It is the inverse function of cosine. The input parameter can be a floating scalar or a float vector. In case of a float vector the arccosine is calculated separately for every component.">Returns the arccosine of an angle in radians. It is ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#arccosine">more</a></td></tr><tr onclick="javascript:"><th>atan(y_over_x)</th><td title="The atan function returns the arctangent of an angle in radians. It is the inverse function of tangent. The input parameter can be a floating scalar or a float vector. In case of a float vector the arctangent is calculated separately for every component.">Returns the arctangent of an angle in radians. It is ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#arctangent">more</a></td></tr><tr onclick="javascript:"><th>pow(x, y)</th><td title="The power function returns x raised to the power of y. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.">Returns x raised to the power of y. The input parameters ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#exponentiation">more</a></td></tr><tr onclick="javascript:"><th>exp(x)</th><td title="The exp function returns the constant e raised to the power of x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns the constant e raised to the power of x. The ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#exponentialfunction">more</a></td></tr><tr onclick="javascript:"><th>log(x)</th><td title="The log function returns the power to which the constant e has to be raised to produce x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns the power to which the constant e has to be ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#naturallogarithm">more</a></td></tr><tr onclick="javascript:"><th>exp2(x)</th><td title="The exp2 function returns 2 raised to the power of x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns 2 raised to the power of x. The input parameter ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#exponentialfunctionbase2">more</a></td></tr><tr onclick="javascript:"><th>log2(x)</th><td title="The log2 function returns the power to which 2 has to be raised to produce x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns the power to which 2 has to be raised to produce ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#logarithmbase2">more</a></td></tr><tr onclick="javascript:"><th>sqrt(x)</th><td title="The sqrt function returns the square root of x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns the square root of x. The input parameter can ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#squareroot">more</a></td></tr><tr onclick="javascript:"><th>inversesqrt(x)</th><td title="The inversesqrt function returns the inverse square root of x, i.e. the reciprocal of the square root. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns the inverse square root of x, i.e. the reciprocal ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#inversesquareroot">more</a></td></tr><tr onclick="javascript:"><th>abs(x)</th><td title="The abs function returns the absolute value of x, i.e. x when x is positive or zero and -x for negative x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns the absolute value of x, i.e. x when x is positive ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#absolutevalue">more</a></td></tr><tr onclick="javascript:"><th>sign(x)</th><td title="The sign function returns 1.0 when x is positive, 0.0 when x is zero and -1.0 when x is negative. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns 1.0 when x is positive, 0.0 when x is zero ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#sign">more</a></td></tr><tr onclick="javascript:"><th>floor(x)</th><td title="The floor function returns the largest integer number that is smaller or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns the largest integer number that is smaller ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#floor">more</a></td></tr><tr onclick="javascript:"><th>ceil(x)</th><td title="The ceiling function returns the smallest number that is larger or equal to x. The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns the smallest number that is larger or equal ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#ceiling">more</a></td></tr><tr onclick="javascript:"><th>fract(x)</th><td title="The fract function returns the fractional part of x, i.e. x minus floor(x). The input parameter can be a floating scalar or a float vector. In case of a float vector the operation is done component-wise.">Returns the fractional part of x, i.e. x minus floor(x). ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#fractionalpart">more</a></td></tr><tr onclick="javascript:"><th>mod(x, y)</th><td title="The mod function returns x minus the product of y and floor(x/y). The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.">Returns x minus the product of y and floor(x/y). The ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#modulo">more</a></td></tr><tr onclick="javascript:"><th>min(x, y)</th><td title="The min function returns the smaller of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.">Returns the smaller of the two arguments. The input ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#minimum">more</a></td></tr><tr onclick="javascript:"><th>max(x, y)</th><td title="The max function returns the larger of the two arguments. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.">Returns the larger of the two arguments. The input ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#maximum">more</a></td></tr><tr onclick="javascript:"><th>clamp(x, minVal, maxVal)</th><td title="The clamp function returns x if it is larger than minVal and smaller than maxVal. In case x is smaller than minVal, minVal is returned. If x is larger than maxVal, maxVal is returned. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.">Returns x if it is larger than minVal and smaller than ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#clamp">more</a></td></tr><tr onclick="javascript:"><th>mix(x, y, a)</th><td title="The mix function returns the linear blend of x and y, i.e. the product of x and (1 - a) plus the product of y and a. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.">Returns the linear blend of x and y, i.e. the product ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#mix">more</a></td></tr><tr onclick="javascript:"><th>step(edge, x)</th><td title="The step function returns 0.0 if x is smaller then edge and otherwise 1.0. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.">Returns 0.0 if x is smaller then edge and otherwise ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#step">more</a></td></tr><tr onclick="javascript:"><th>smoothstep(edge0, edge1, x)</th><td title="The smoothstep function returns 0.0 if x is smaller then edge0 and 1.0 if x is larger than edge1. Otherwise the return value is interpolated between 0.0 and 1.0 using Hermite polynomirals. The input parameters can be floating scalars or float vectors. In case of float vectors the operation is done component-wise.">Returns 0.0 if x is smaller then edge0 and 1.0 if x ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#smoothstep">more</a></td></tr><tr onclick="javascript:"><th>length(x)</th><td title="The length function returns the length of a vector defined by the Euclidean norm, i.e. the square root of the sum of the squared components. The input parameter can be a floating scalar or a float vector. In case of a floating scalar the length function is trivial and returns the absolute value.">Returns the length of a vector defined by the Euclidean ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#length">more</a></td></tr><tr onclick="javascript:"><th>distance(p0, p1)</th><td title="The distance function returns the distance between two points. The distance of two points is the length of the vector d = p0 - p1, that starts at p1 and points to p0. The input parameters can be floating scalars or float vectors. In case of floating scalars the distance function is trivial and returns the absolute value of d.">Returns the distance between two points. The distance ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#distance">more</a></td></tr><tr onclick="javascript:"><th>dot(x, y)</th><td title="The dot function returns the dot product of the two input parameters, i.e. the sum of the component-wise products. If x and y are the same the square root of the dot product is equivalent to the length of the vector. The input parameters can be floating scalars or float vectors. In case of floating scalars the dot function is trivial and returns the product of x and y.">Returns the dot product of the two input parameters, ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#dotproduct">more</a></td></tr><tr onclick="javascript:"><th>cross(x, y)</th><td title="The cross function returns the cross product of the two input parameters, i.e. a vector that is perpendicular to the plane containing x and y and has a magnitude that is equal to the area of the parallelogram that x and y span. The input parameters can only be 3-component floating vectors. The cross product is equivalent to the product of the length of the vectors times the sinus of the(smaller) angle between x and y.">Returns the cross product of the two input parameters, ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#crossproduct">more</a></td></tr><tr onclick="javascript:"><th>normalize(x)</th><td title="The normalize function returns a vector with length 1.0 that is parallel to x, i.e. x divided by its length. The input parameter can be a floating scalar or a float vector. In case of a floating scalar the normalize function is trivial and returns 1.0.">Returns a vector with length 1.0 that is parallel to ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#normalize">more</a></td></tr><tr onclick="javascript:"><th>faceforward(N, I, Nref)</th><td title="The faceforward function returns a vector that points in the same direction as a reference vector. The function has three input parameters of the type floating scalar or float vector: N, the vector to orient, I, the incident vector, and Nref, the reference vector. If the dot product of I and Nref is smaller than zero the return value is N. Otherwise -N is returned.">Returns a vector that points in the same direction ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#faceforward">more</a></td></tr><tr onclick="javascript:"><th>reflect(I, N)</th><td title="The reflect function returns a vector that points in the direction of reflection. The function has two input parameters of the type floating scalar or float vector: I, the incident vector, and N, the normal vector of the reflecting surface.">Returns a vector that points in the direction of reflection. ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#reflect">more</a></td></tr><tr onclick="javascript:"><th>refract(I, N, eta)</th><td title="The refract function returns a vector that points in the direction of refraction. The function has two input parameters of the type floating scalar or float vector and one input parameter of the type floating scalar: I, the incident vector, N, the normal vector of the refracting surface, and eta, the ratio of indices of refraction.">Returns a vector that points in the direction of refraction. ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#refract">more</a></td></tr><tr onclick="javascript:"><th>matrixCompMult(x, y)</th><td title="The matrixCompMult function returns a matrix resulting from a component-wise multiplication. The function has two input parameters of the type floating point matrix and returns a matrix of the same type. The indices of the returned matrix are calculated as follows: z[i][j] = x[i][j] * y[i][j] ">Returns a matrix resulting from a component-wise multiplication. ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#componentwisematrixmultiplication">more</a></td></tr><tr onclick="javascript:"><th>lessThan(x, y)</th><td title="The lessThan function returns a boolean vector as result of a component-wise comparison in the form of x[i] < y[i]. The function has two input parameters of the type floating point vector or signed integer vector.">Returns a boolean vector as result of a component-wise ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#lessthancomparison">more</a></td></tr><tr onclick="javascript:"><th>lessThanEqual(x, y)</th><td title="The lessThanEqual function returns a boolean vector as result of a component-wise comparison in the form of x[i] <= y[i]. The function has two input parameters of the type floating point vector or signed integer vector.">Returns a boolean vector as result of a component-wise ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#lessthanorequalcomparison">more</a></td></tr><tr onclick="javascript:"><th>greaterThan(x, y)</th><td title="The greaterThan function returns a boolean vector as result of a component-wise comparison in the form of x[i] > y[i]. The function has two input parameters of the type floating point vector or signed integer vector.">Returns a boolean vector as result of a component-wise ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#greaterthancomparison">more</a></td></tr><tr onclick="javascript:"><th>greaterThanEqual(x, y)</th><td title="The greaterThanEqual function returns a boolean vector as result of a component-wise comparison in the form of x[i] >= y[i]. The function has two input parameters of the type floating point vector or signed integer vector.">Returns a boolean vector as result of a component-wise ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#greaterthanorequalcomparison">more</a></td></tr><tr onclick="javascript:"><th>equal(x, y)</th><td title="The equal function returns a boolean vector as result of a component-wise comparison in the form of x[i] = y[i]. The function has two input parameters of the type floating point vector or signed integer vector.">Returns a boolean vector as result of a component-wise ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#equalcomparison">more</a></td></tr><tr onclick="javascript:"><th>notEqual(x, y)</th><td title="The notEqual function returns a boolean vector as result of a component-wise comparison in the form of x[i] != y[i]. The function has two input parameters of the type floating point vector or signed integer vector.">Returns a boolean vector as result of a component-wise ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#notequalcomparison">more</a></td></tr><tr onclick="javascript:"><th>any(x)</th><td title="The any function returns a boolean value as result of the evaluation whether any component of the input vector is TRUE. The function has one input parameters of the type boolean vector.">Returns a boolean value as result of the evaluation ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#anyevaluation">more</a></td></tr><tr onclick="javascript:"><th>all(x)</th><td title="The all function returns a boolean value as result of the evaluation whether all components of the input vector are TRUE. The function has one input parameters of the type boolean vector.">Returns a boolean value as result of the evaluation ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#allevaluation">more</a></td></tr><tr onclick="javascript:"><th>texture2D(sampler, coord)</th><td title="The texture2D function returns a texel, i.e. the (color) value of the texture for the given coordinates. The function has one input parameter of the type sampler2D and one input parameter of the type vec2 : sampler, the uniform the texture is bound to, and coord, the 2-dimensional coordinates of the texel to look up.">Returns a texel, i.e. the (color) value of the texture ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#2dtexturelookup">more</a></td></tr><tr onclick="javascript:"><th>textureCube(sampler, coord)</th><td title="The textureCube function returns a texel, i.e. the (color) value of the texture for the given coordinates. The function has one input parameter of the type samplerCube and one input parameter of the type vec3 : sampler, the uniform the texture is bound to, and coord, the 3-dimensional coordinates of the texel to look up.">Returns a texel, i.e. the (color) value of the texture ... <a class="more-link" target="_blank" href="http://www.shaderific.com/glsl-functions/#cubemaptexturelookup">more</a></td></tr></tbody></table>

				</div>
			</div>
		</div>
	</div>

	<!-- libs -->
	<script type="text/javascript" charset="utf-8" src="js/ace/ace.js"></script>
	<script type="text/javascript" charset="utf-8" src="js/ace/ext-static_highlight.js"></script>
	<!--<script type="text/javascript" src="js/three/three.min.js"></script>-->

	<!-- app -->
	<script type="text/javascript" src="js/demo.js"></script>
	<script type="text/javascript" src="js/shader-preview.js"></script>
	<script type="text/javascript" src="js/ui.js"></script>
	<script type="text/javascript" src="js/app.js"></script>
</body>
</html>